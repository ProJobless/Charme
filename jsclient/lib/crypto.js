function crypto_rsaDecrypt(eText, key)
{
	var rsa = new RSAKey();

	rsa.setPrivateEx(key.n, key.e, key.d,
			key.p, key.q, key.dmp1,
			key.dmq1, key.coeff);

	var plain = rsa.decrypt(eText);
	if (plain == null)
	console.warn("RSA decrypted text is null!");
	return plain;
}
function crypto_rsaDecryptWithRevision(eText, revision)
{
	var key1 = getKeyByRevision(revision);
	return crypto_rsaDecrypt(eText, key1.rsa.rsa)
}
function crypto_rsaEncrypt(text, key)
{
	var rsa = new RSAKey();

	rsa.setPrivateEx(key.n, key.e, key.d,
			key.p, key.q, key.dmp1,
			key.dmq1, key.coeff);

	return rsa.encrypt(text);
}

function cryptotest()
{
	var msg = "ein test";
	var sign = crypto_sign(msg);

	console.log(crypto_checksign(sign, msg, ""));
		console.log(crypto_checksign(sign, "false signature", ""));
	//console.log(crypto_checksign(sign, "boese nachricht", ""));
}

function decryptKeyDirValue(keyvalue)
{
	var fastkey = getFastKey(0, 1);
	return $.parseJSON(aes_decrypt(fastkey.fastkey1,keyvalue));

}

/***
	Name:
	crypto_checkKeyUpdate

	Info:
	Check if public keys are up to date.
	Returns an array with outdated keys.


	Location:
	crypto.js

	Code:JS:
	upToDate = crypto_checkKeyUpdate(["test@test.de", "test2@test3.de"]);
*/

function crypto_checkKeyUpdate(inputItems)
{
	var fastkey = getFastKey(0, 1);
	var key = getKeyByRevision(0);
	var text = CryptoJS.SHA256(key.rsa.rsa.n).toString(CryptoJS.enc.Base64);

	var output = [];

	$.each(inputItems, function(index, item) {
			output.push();
	});
}


/***
	Name:
	crypto_hmac_make

	Info:
	Generates a hmac of an object with fastkey1.

	Params:
	obj:string or object:a string or object where integrity protection is needed
	customKey (optional): A custom key that is not the fastkey for the signature generation
  customKeyRevision (if customKey was provided): An revision as integer

	Location:
	crypto.js

	Code:JS:
	crypto_hmac_make({test: test})

*/

function crypto_hmac_make(obj, customKey, customKeyRevision) {

	var objType = "string"; // We support both object and strings for the hmac
	var hmacStr; // the final hmac of the object or string

	if (obj !== null && typeof obj === 'object') {
		objType = "object";
		hmacStr = JSON.stringify(obj);
	}
	else {
		hmacStr = obj; // object is a stirng
	}

	if (typeof customKey === 'undefined') {
		var fk1 = getFastKey(0, 1);
		customKeyRevision = fk1.revision;
		customKey = fk1.fastkey1;
	}

	var hmac = CryptoJS.HmacSHA256(hmacStr+customKeyRevision, customKey).toString(CryptoJS.enc.Base64);
	var fullObject =  {
		"revision": customKeyRevision, // fastkey revision
		"hmac": hmac,
		"obj": obj,
		"objType": objType
	}
	return fullObject;
}


/***
	Name:
	crypto_hmac_check

	Info:
	Check if object hmac is correct and the object was not modified.

	Params:
	fullObject:object: A object generated by crypto_hmac_make

	Location:
	crypto.js

	Code:JS:
	crypto_hmac_check(crypto_hmac_make({test: test})) // should return true

*/

function crypto_hmac_check(fullObject) {
	var hmacStr; // the final hmac of the object or string

	if (fullObject.objType == "string") {
		hmacStr = fullObject.obj;
	}
	else if (fullObject.objType == "object") {
		hmacStr = JSON.stringify(fullObject.obj);
	}



	var fk1 = getFastKey(fullObject.revision, 1);

	var hmac = CryptoJS.HmacSHA256(hmacStr+fk1.revision, fk1.fastkey1).toString(CryptoJS.enc.Base64);

	if (fullObject.hmac == hmac)
	return true;
	else {
		return false;
	}
}

// OUTDATED FUNCTION!!!! use crypto_decryptFK1 instead!
function aes_decryptWithFastKey1(message, revision)
{
	var fk1 = getFastKey(revision, 1);
	return {message: aes_decrypt(fk1.fastkey1, message)};
}


/***
	Name:
	crypto_encryptFK1

	Info:
	Encrypts some text using fastkey1 and also generates
	a hmac of message and revision to ensure, that no old revision with a
	modified content is returned when an old fastkey1 was compromised.

	Location:
	crypto.js

	Code:JS:
	somekey = crypto_encryptFK1("Hallo", 0);
*/

function crypto_encryptFK1(message, revision, encryptionKey)
{
	if (typeof revision === 'undefined')
		revision = 0;

	var keyRevision;

	if (typeof encryptionKey !== 'undefined') {
		keyRevision = revision;
	}
	else {
		var fk1 = getFastKey(revision, 1);
		encryptionKey = fk1.fastkey1;
		keyRevision = fk1.revision;
	}
	// TODO: Derive hmac key with PBKDF2 etc.

	var encryptedMessageText = aes_encrypt(encryptionKey, message);
	var encryptedMessage = {
		ciphertext: encryptedMessageText,
		hmac: CryptoJS.HmacSHA256(encryptedMessageText+keyRevision, encryptionKey).toString(CryptoJS.enc.Base64) , // TODO: use other key instead for hmac!!!
		revision: keyRevision
	}
	return {message: encryptedMessage, revision: keyRevision};
}

function crypto_recryptFK1(message) {
	plain = crypto_decryptFK1(message);
	return crypto_encryptFK1(plain.message, 0);

}
/***
	Name:
	crypto_decryptFK1

	Info:
	Decrypts some object encrypted with aes_encryptFK1

	Location:
	crypto.js

	Code:JS:
	somekey = crypto_decryptFK1(encryptedMessage, 0);
*/

function crypto_decryptFK1(encryptedObject)
{
	var fk1 = getFastKey(encryptedObject.revision, 1);
	var decryptedMessage = aes_decrypt(fk1.fastkey1, encryptedObject.ciphertext);
	if (encryptedObject.hmac ==  CryptoJS.HmacSHA256(encryptedObject.ciphertext+encryptedObject.revision, fk1.fastkey1).toString(CryptoJS.enc.Base64))
	return {message: decryptedMessage, revision: fk1.revision};
	else {
		return {error: 1}
	}
}

function aes_encrypt_json(pass, obj)
{
	return aes_encrypt(pass, JSON.stringify(obj));
}

function aes_decrypt_json(pass, obj)
{
	return aes_decrypt(pass, $.parse(obj));
}
/***
	Name:
	aes_encryypt

	Info:
	Encrypts String with AES Key


	Location:
	crypto.js

	Code:JS:
	enctext= aes_encrypt("myaeskey", "mytext");
*/

var AES_ALGORITHM_VERSION = 1;

function aes_encrypt(pass, text)
{

	if (AES_ALGORITHM_VERSION == 0)
		return GibberishAES.enc(text, pass).replace(/(\r\n|\n|\r)/gm,"\n");

		// TODO: USE PBKDF2 to generate different keys for integrity protection and encryption

		else if (AES_ALGORITHM_VERSION == 1) {
			var password = pass+AES_ALGORITHM_VERSION; // Append algorithm version to avoid backward compatibility attacks
			var chypertext = GibberishAES.enc(text, password).replace(/(\r\n|\n|\r)/gm,"\n"); 	// .replace does a linebreak cleanup
			var hmac = CryptoJS.HmacSHA256(chypertext, password).toString(CryptoJS.enc.Base64);

			return JSON.stringify({
				a: 1,
				m: chypertext,
				h: hmac
			});
	}
}


/***
	Name:
	aes_decryypt

	Info:
	Decrypts String with AES Key, returns string


	Location:
	crypto.js

	Code:JS:
	enctext= aes_decrypt("myaeskey", "mytext");
*/

function aes_decrypt(pass, encText)
{

	try
	{

	   var json = JSON.parse(encText);

		 if (json.a == 1) {
				var password = pass+json.a;
				var chypertext = json.m;

				var plaintext = GibberishAES.dec(chypertext.replace(/(\r\n|\n|\r)/gm,"\n"), password); 	// .replace does a linebreak cleanup
				var hmacNew = CryptoJS.HmacSHA256(chypertext, password).toString(CryptoJS.enc.Base64);
				//console.log("new hmac is+"+hmacNew+"     "+ json.h ); // TODO: HMAC does not work correclty in threads


				if (json.h == hmacNew)
					return plaintext;
				else {
					alert("HMAC ERROR");
				}
			}
			else {
				alert("AES Cryptoversion not supportet. maybe you need to upgrade Charme");
			}
	}
	catch(e)
	{
		if (typeof encText ==="undefined")
			console.warn("Encoded object was undefined at aes_decrypt");


		console.log(e);

		 return GibberishAES.dec(encText.replace(/(\r\n|\n|\r)/gm,"\n"), pass); // .replace does a linebreak cleanup
	}
}

/***
	Name:
	checkCache

	Info:
	Uses  local storage cache to get data encrypted with fastkey1.
	Useful for RSA decrypted values for example. Returns false if Cache was empty


	Location:
	crypto.js

	Code:JS:
	var x = checkCache("key");
	if (x == null)
	{
	  x = 4+4;
	  storeCache("key", x);
	}

	alert(x);

*/

function checkCache(key2)
{

	var txt = localStorage.getItem(charmeUser.userId+key2);

	if (txt == null)
	{
		console.log("NULL"+charmeUser.userId+key2);
		return null;
	}

	var data = txt.split(',');

		try {
		var txt = crypto_decryptFK1(key.fastkey1, data[1]);
		 	return txt;
	}
	catch(err) {
		console.warn("CACHE ERROR:");
		console.log(err.message);
		return null;
	}
}


/***
	Name:
	storeCache

	Info:
	Uses  local storage cache to store data encrypted with fastkey1.
	Useful for RSA decrypted values for example. See also: checkCache


	Location:
	crypto.js

	Code:JS:
	var x = checkCache("key");
	if (x == false)
	{
	  x = 4+4;
	  storeCache("key", x);
	}

	alert(x);

*/

function storeCache(key2, value)
{
	var txt = crypto_encryptFK1(value);
 	localStorage.setItem(charmeUser.userId+key2, txt);
}

/***
	Name:
	mkRSAPublic

	Info:
	Generate a public RSA Object which prodvides encrypt functions


	Location:
	crypto.js

	Code:JS:
	var key = { n: 12345..., e: 100011} // Do not define n and e yourself!
	var rsa = mkRSAPublic(key);
	rsa.encrypt(...);
*/


function mkRSAPublic(key)
{
	var rsa = new RSAKey();
	rsa.setPublic(key.n, key.e);
	return rsa;
}




/***
	Name:
	mkRSA

	Info:
	Generate RSA Object which prodvides encrypt/decrypt functions
	of Key Object


	Location:
	crypto.js

	Code:JS:
	var rsa = mkRSA(key);
	rsa.encrypt(...);
*/


function mkRSA(key)
{

	var rsa = new RSAKey();

	rsa.setPrivateEx(key.n, key.e, key.d,
		key.p, key.q, key.dmp1,
		key.dmq1, key.coeff);
	return rsa;

}

/***
	Name:
	getFastKey

	Info:
	Get symmetric AES key for fast encryption/decryption
	First Parameter is certificate Version, second is fastkey number
	(which is 1 or 2)
	Returns {fastkey1, revision}


	Params:
	version:int:fast key version, must be saved in fastkey encrypted values to maintain decryption ability for older values.
	number:int:1 or 2


	Location:
	crypto.js

	Code:JS:
	var key1 = getFastKey(0, 1);
*/



function getFastKey(version, number) {
	var key1 = getKeyByRevision(version);
	if (number == 1)
		return {
			fastkey1: key1.fastkey1,
			revision: key1.revision
		};
	if (number == 2)
		return {
			fastkey2: key1.fastkey2,
			revision: key1.revision
		};
}
/***
	Name:
	getCurrentFastKey

	Info:
	Returns current fast key.

	Params:
	number:int:1 or 2

	Location:
	crypto.js

	Code:JS:
	var fk = getFastKey(getCurrentFastKey);
*/


function getCurrentFastKey(number)
{
	return getFastKey(0,number);
}


/***
	Name:
	getCurrentRSAKey

	Info:
	Returns current RSA Key in form {rsa, revision}

	Location:
	crypto.js

	Code:JS:
	var rsa = function getCurrentRSAKey()
*/



function getCurrentRSAKey() {

	var rsa = new RSAKey();

	var key1 = getKeyByRevision(0);

	var key = key1.rsa;

	rsa.setPrivateEx(key.n, key.e, key.d,
		key.p, key.q, key.dmp1,
		key.dmq1, key.coeff);


	return {rsa: rsa, revision: key1.revision};
}

/***
	Name:
	randomSalt

	Info:
	Generates a random Salt for SHA256 Hashing

	TODO:LV1: USE WEB CRYPTO API! INSECURE OTHERWISE!

	Params:
	lenghtInByte:int:Salt lenght in byte

	Location:
	apl/crypto.js

	Code:JS:
	var k = randomSalt(32);

*/



function randomSalt(lenghtInByte)
{

var key = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for( var i=0; i < 20; i++ )
        key += possible.charAt(Math.floor(Math.random() * possible.length));
return key;


}




/***
	Name:
	randomAesKey

	Info:
	Generates a random AES Key.

	TODO:LV1: Add Mouse movement etc. as `Math.random()` is NOT a reliable RNG. -> USE WEB CRYPTO API!

	Params:
	lenghtInByte:int:Key lenght in byte

	Location:
	apl/crypto.js

	Code:JS:
	var k = randomAesKey(32); // Generate a random AES key with lenght of 256 Bit.

*/


// maye a more secure sjcl function is var randKey  = sjcl.random.randomWords(4, 0);

function randomAesKey(lenghtInByte)
{

var key = "";
    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

    for( var i=0; i < 20; i++ )
        key += possible.charAt(Math.floor(Math.random() * possible.length));
return key;


}
