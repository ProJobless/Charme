
class CharmeModels.Signature
	@hash
	@revision
	###

	Name:
	Signature(originalMessage)

	Info:
	Generate a signature with the users private key.
	
	Params:
	message:string:The message you want to sign

	Location:
	crypto.js

	Code:JS:
	var signature = crypto_sign("hallo welt", );

	###

	constructor: (originalMessage) -> # the @ sign makes attributes globally accesable
		rsa = new RSAKey()
		key1 = getKeyByRevision(0)
		this.revision = key1.revision
		rsa.setPrivateEx(key1.rsa.rsa.n, key1.rsa.rsa.e, key1.rsa.rsa.d,
						key1.rsa.rsa.p, key1.rsa.rsa.q, key1.rsa.rsa.dmp1,
						key1.rsa.rsa.dmq1, key1.rsa.rsa.coeff);
		console.log("---------------------------")
		console.log originalMessage
		this.hash = rsa.signStringWithSHA1(originalMessage);

	###
	
	Name:
	Signature.Verify(hash, message2verify, publicKey)

	Info:
	Verify a signature. Returns TRUE or FALSE

	Params:
	signature:string:The signature to check
	message:string:The message you want to check
	publicKey:object:The publicKey (usually from key directory)

	Location:
	crypto.js

	Code:JS:
	// TODO


	###
	@Verify: (hash2Check, message2verify, publicKey) -> # a static function to verify signatures
		key1 = getKeyByRevision(0)

		alert("SIGNATURE VERIFICATION NOT WORKING YET!!!")

		x509 = new X509()
		x509.readCertNE(key1.rsa.rsa.n, key1.rsa.rsa.e)
		result = x509.subjectPublicKeyRSA.verifyString(message, signature)

		if result==true
			return true
		else
			return false

	# convert key to real pem format with line breaks and -----headers-----
	@keyToPem: (n,e) ->
		rsa = new RSAKey()
		rsa.setPublic(n,e)
		pem = rsa.publicKeyToX509PemString()
		# now we have thew raw base64 pem key. we have to add linebreaks and headers
		# break
		linecount = Math.ceil(pem.length/64)

		pemnew = "-----BEGIN PUBLIC KEY-----\n"
		i=0
		while i<linecount
			pemnew += pem.substr(i*64, 64)+"\n"
			i++

		pemnew += "-----END PUBLIC KEY-----"
	toJSON: () ->
		return {keyRevision: this.revision, hashvalue: this.hash }

	@showDialog: () ->
		$.get "templates/box_checksign.html", (d) ->
			_.templateSettings.variable = "rc";
			template = _.template(d, null);

			ui_showBox template, ->

	# This function generates a JSON container that is signed with RSA signature

	###

		Return Form: {object, signature {keyRevision, hashvalue}}

	###
	@makeSignedJSON: (object) ->
		jsonString = JSON.stringify(object)
		
		console.log (jsonString)
		console.log ("signature is")
		theSignature = new CharmeModels.Signature(jsonString);
		console.log theSignature
		return {"object":object, "signature": theSignature.toJSON()}

	# verify a signed json object, returns true (key ok) or false (key not ok)
	# input: a object generated by makeSignedJSON, and a public key in form {rsa{rsa{n,e}}}
	@verifySignedJSON: (object, key) ->
		str =  JSON.stringify(object)
		return CharmeModels.Signature.Verify(object.signature.hashvalue, str, key)		
